// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package mssql

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
	"github.com/pulumiverse/pulumi-mssql/sdk/go/mssql/internal"
)

// Allows execution of arbitrary SQL scripts to check state and apply desired state.
//
// > **Note** This resource is meant to be an escape hatch for all cases not supported by the provider's resources. Whenever possible, use dedicated resources, which offer better plan, validation and error reporting.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumiverse/pulumi-mssql/sdk/go/mssql"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			test, err := mssql.LookupDatabase(ctx, &mssql.LookupDatabaseArgs{
//				Name: "test",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = mssql.NewScript(ctx, "cdc", &mssql.ScriptArgs{
//				DatabaseId:   *pulumi.String(test.Id),
//				ReadScript:   pulumi.String(fmt.Sprintf("SELECT COUNT(*) AS [is_enabled] FROM sys.change_tracking_databases WHERE database_id=%v", test.Id)),
//				DeleteScript: pulumi.String(fmt.Sprintf("ALTER DATABASE [%v] SET CHANGE_TRACKING = OFF", test.Name)),
//				UpdateScript: pulumi.String(fmt.Sprintf("IF (SELECT COUNT(*) FROM sys.change_tracking_databases WHERE database_id=%v) = 0\n  ALTER DATABASE [%v] SET CHANGE_TRACKING = ON\n", test.Id, test.Name)),
//				State: pulumi.StringMap{
//					"is_enabled": pulumi.String("1"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type Script struct {
	pulumi.CustomResourceState

	// SQL script executed when the resource does not exist in Terraform state. When not provided, `update_script` will be used
	// to create the resource.
	CreateScript pulumi.StringPtrOutput `pulumi:"createScript"`
	// ID of database. Can be retrieved using `Database` or `SELECT DB_ID('<db_name>')`.
	DatabaseId pulumi.StringOutput `pulumi:"databaseId"`
	// SQL script executed when the resource is being destroyed. When not provided, no action will be taken during resource destruction.
	DeleteScript pulumi.StringPtrOutput `pulumi:"deleteScript"`
	// SQL script returning current state of the DB. It must return single-row result set where column names match the keys of `state` map and all values are strings that will be compared against `state` to determine if the resource state matches DB state.
	ReadScript pulumi.StringOutput `pulumi:"readScript"`
	// Desired state of the DB. It is arbitrary map of string values that will be compared against the values returned by the `readScript`.
	State pulumi.StringMapOutput `pulumi:"state"`
	// SQL script executed when the desired state specified in `state` attribute does not match the state returned by `readScript`
	UpdateScript pulumi.StringOutput `pulumi:"updateScript"`
}

// NewScript registers a new resource with the given unique name, arguments, and options.
func NewScript(ctx *pulumi.Context,
	name string, args *ScriptArgs, opts ...pulumi.ResourceOption) (*Script, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DatabaseId == nil {
		return nil, errors.New("invalid value for required argument 'DatabaseId'")
	}
	if args.ReadScript == nil {
		return nil, errors.New("invalid value for required argument 'ReadScript'")
	}
	if args.State == nil {
		return nil, errors.New("invalid value for required argument 'State'")
	}
	if args.UpdateScript == nil {
		return nil, errors.New("invalid value for required argument 'UpdateScript'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Script
	err := ctx.RegisterResource("mssql:index/script:Script", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetScript gets an existing Script resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetScript(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ScriptState, opts ...pulumi.ResourceOption) (*Script, error) {
	var resource Script
	err := ctx.ReadResource("mssql:index/script:Script", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Script resources.
type scriptState struct {
	// SQL script executed when the resource does not exist in Terraform state. When not provided, `update_script` will be used
	// to create the resource.
	CreateScript *string `pulumi:"createScript"`
	// ID of database. Can be retrieved using `Database` or `SELECT DB_ID('<db_name>')`.
	DatabaseId *string `pulumi:"databaseId"`
	// SQL script executed when the resource is being destroyed. When not provided, no action will be taken during resource destruction.
	DeleteScript *string `pulumi:"deleteScript"`
	// SQL script returning current state of the DB. It must return single-row result set where column names match the keys of `state` map and all values are strings that will be compared against `state` to determine if the resource state matches DB state.
	ReadScript *string `pulumi:"readScript"`
	// Desired state of the DB. It is arbitrary map of string values that will be compared against the values returned by the `readScript`.
	State map[string]string `pulumi:"state"`
	// SQL script executed when the desired state specified in `state` attribute does not match the state returned by `readScript`
	UpdateScript *string `pulumi:"updateScript"`
}

type ScriptState struct {
	// SQL script executed when the resource does not exist in Terraform state. When not provided, `update_script` will be used
	// to create the resource.
	CreateScript pulumi.StringPtrInput
	// ID of database. Can be retrieved using `Database` or `SELECT DB_ID('<db_name>')`.
	DatabaseId pulumi.StringPtrInput
	// SQL script executed when the resource is being destroyed. When not provided, no action will be taken during resource destruction.
	DeleteScript pulumi.StringPtrInput
	// SQL script returning current state of the DB. It must return single-row result set where column names match the keys of `state` map and all values are strings that will be compared against `state` to determine if the resource state matches DB state.
	ReadScript pulumi.StringPtrInput
	// Desired state of the DB. It is arbitrary map of string values that will be compared against the values returned by the `readScript`.
	State pulumi.StringMapInput
	// SQL script executed when the desired state specified in `state` attribute does not match the state returned by `readScript`
	UpdateScript pulumi.StringPtrInput
}

func (ScriptState) ElementType() reflect.Type {
	return reflect.TypeOf((*scriptState)(nil)).Elem()
}

type scriptArgs struct {
	// SQL script executed when the resource does not exist in Terraform state. When not provided, `update_script` will be used
	// to create the resource.
	CreateScript *string `pulumi:"createScript"`
	// ID of database. Can be retrieved using `Database` or `SELECT DB_ID('<db_name>')`.
	DatabaseId string `pulumi:"databaseId"`
	// SQL script executed when the resource is being destroyed. When not provided, no action will be taken during resource destruction.
	DeleteScript *string `pulumi:"deleteScript"`
	// SQL script returning current state of the DB. It must return single-row result set where column names match the keys of `state` map and all values are strings that will be compared against `state` to determine if the resource state matches DB state.
	ReadScript string `pulumi:"readScript"`
	// Desired state of the DB. It is arbitrary map of string values that will be compared against the values returned by the `readScript`.
	State map[string]string `pulumi:"state"`
	// SQL script executed when the desired state specified in `state` attribute does not match the state returned by `readScript`
	UpdateScript string `pulumi:"updateScript"`
}

// The set of arguments for constructing a Script resource.
type ScriptArgs struct {
	// SQL script executed when the resource does not exist in Terraform state. When not provided, `update_script` will be used
	// to create the resource.
	CreateScript pulumi.StringPtrInput
	// ID of database. Can be retrieved using `Database` or `SELECT DB_ID('<db_name>')`.
	DatabaseId pulumi.StringInput
	// SQL script executed when the resource is being destroyed. When not provided, no action will be taken during resource destruction.
	DeleteScript pulumi.StringPtrInput
	// SQL script returning current state of the DB. It must return single-row result set where column names match the keys of `state` map and all values are strings that will be compared against `state` to determine if the resource state matches DB state.
	ReadScript pulumi.StringInput
	// Desired state of the DB. It is arbitrary map of string values that will be compared against the values returned by the `readScript`.
	State pulumi.StringMapInput
	// SQL script executed when the desired state specified in `state` attribute does not match the state returned by `readScript`
	UpdateScript pulumi.StringInput
}

func (ScriptArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*scriptArgs)(nil)).Elem()
}

type ScriptInput interface {
	pulumi.Input

	ToScriptOutput() ScriptOutput
	ToScriptOutputWithContext(ctx context.Context) ScriptOutput
}

func (*Script) ElementType() reflect.Type {
	return reflect.TypeOf((**Script)(nil)).Elem()
}

func (i *Script) ToScriptOutput() ScriptOutput {
	return i.ToScriptOutputWithContext(context.Background())
}

func (i *Script) ToScriptOutputWithContext(ctx context.Context) ScriptOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScriptOutput)
}

func (i *Script) ToOutput(ctx context.Context) pulumix.Output[*Script] {
	return pulumix.Output[*Script]{
		OutputState: i.ToScriptOutputWithContext(ctx).OutputState,
	}
}

// ScriptArrayInput is an input type that accepts ScriptArray and ScriptArrayOutput values.
// You can construct a concrete instance of `ScriptArrayInput` via:
//
//	ScriptArray{ ScriptArgs{...} }
type ScriptArrayInput interface {
	pulumi.Input

	ToScriptArrayOutput() ScriptArrayOutput
	ToScriptArrayOutputWithContext(context.Context) ScriptArrayOutput
}

type ScriptArray []ScriptInput

func (ScriptArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Script)(nil)).Elem()
}

func (i ScriptArray) ToScriptArrayOutput() ScriptArrayOutput {
	return i.ToScriptArrayOutputWithContext(context.Background())
}

func (i ScriptArray) ToScriptArrayOutputWithContext(ctx context.Context) ScriptArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScriptArrayOutput)
}

func (i ScriptArray) ToOutput(ctx context.Context) pulumix.Output[[]*Script] {
	return pulumix.Output[[]*Script]{
		OutputState: i.ToScriptArrayOutputWithContext(ctx).OutputState,
	}
}

// ScriptMapInput is an input type that accepts ScriptMap and ScriptMapOutput values.
// You can construct a concrete instance of `ScriptMapInput` via:
//
//	ScriptMap{ "key": ScriptArgs{...} }
type ScriptMapInput interface {
	pulumi.Input

	ToScriptMapOutput() ScriptMapOutput
	ToScriptMapOutputWithContext(context.Context) ScriptMapOutput
}

type ScriptMap map[string]ScriptInput

func (ScriptMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Script)(nil)).Elem()
}

func (i ScriptMap) ToScriptMapOutput() ScriptMapOutput {
	return i.ToScriptMapOutputWithContext(context.Background())
}

func (i ScriptMap) ToScriptMapOutputWithContext(ctx context.Context) ScriptMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScriptMapOutput)
}

func (i ScriptMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*Script] {
	return pulumix.Output[map[string]*Script]{
		OutputState: i.ToScriptMapOutputWithContext(ctx).OutputState,
	}
}

type ScriptOutput struct{ *pulumi.OutputState }

func (ScriptOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Script)(nil)).Elem()
}

func (o ScriptOutput) ToScriptOutput() ScriptOutput {
	return o
}

func (o ScriptOutput) ToScriptOutputWithContext(ctx context.Context) ScriptOutput {
	return o
}

func (o ScriptOutput) ToOutput(ctx context.Context) pulumix.Output[*Script] {
	return pulumix.Output[*Script]{
		OutputState: o.OutputState,
	}
}

// SQL script executed when the resource does not exist in Terraform state. When not provided, `update_script` will be used
// to create the resource.
func (o ScriptOutput) CreateScript() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Script) pulumi.StringPtrOutput { return v.CreateScript }).(pulumi.StringPtrOutput)
}

// ID of database. Can be retrieved using `Database` or `SELECT DB_ID('<db_name>')`.
func (o ScriptOutput) DatabaseId() pulumi.StringOutput {
	return o.ApplyT(func(v *Script) pulumi.StringOutput { return v.DatabaseId }).(pulumi.StringOutput)
}

// SQL script executed when the resource is being destroyed. When not provided, no action will be taken during resource destruction.
func (o ScriptOutput) DeleteScript() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Script) pulumi.StringPtrOutput { return v.DeleteScript }).(pulumi.StringPtrOutput)
}

// SQL script returning current state of the DB. It must return single-row result set where column names match the keys of `state` map and all values are strings that will be compared against `state` to determine if the resource state matches DB state.
func (o ScriptOutput) ReadScript() pulumi.StringOutput {
	return o.ApplyT(func(v *Script) pulumi.StringOutput { return v.ReadScript }).(pulumi.StringOutput)
}

// Desired state of the DB. It is arbitrary map of string values that will be compared against the values returned by the `readScript`.
func (o ScriptOutput) State() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Script) pulumi.StringMapOutput { return v.State }).(pulumi.StringMapOutput)
}

// SQL script executed when the desired state specified in `state` attribute does not match the state returned by `readScript`
func (o ScriptOutput) UpdateScript() pulumi.StringOutput {
	return o.ApplyT(func(v *Script) pulumi.StringOutput { return v.UpdateScript }).(pulumi.StringOutput)
}

type ScriptArrayOutput struct{ *pulumi.OutputState }

func (ScriptArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Script)(nil)).Elem()
}

func (o ScriptArrayOutput) ToScriptArrayOutput() ScriptArrayOutput {
	return o
}

func (o ScriptArrayOutput) ToScriptArrayOutputWithContext(ctx context.Context) ScriptArrayOutput {
	return o
}

func (o ScriptArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*Script] {
	return pulumix.Output[[]*Script]{
		OutputState: o.OutputState,
	}
}

func (o ScriptArrayOutput) Index(i pulumi.IntInput) ScriptOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Script {
		return vs[0].([]*Script)[vs[1].(int)]
	}).(ScriptOutput)
}

type ScriptMapOutput struct{ *pulumi.OutputState }

func (ScriptMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Script)(nil)).Elem()
}

func (o ScriptMapOutput) ToScriptMapOutput() ScriptMapOutput {
	return o
}

func (o ScriptMapOutput) ToScriptMapOutputWithContext(ctx context.Context) ScriptMapOutput {
	return o
}

func (o ScriptMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*Script] {
	return pulumix.Output[map[string]*Script]{
		OutputState: o.OutputState,
	}
}

func (o ScriptMapOutput) MapIndex(k pulumi.StringInput) ScriptOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Script {
		return vs[0].(map[string]*Script)[vs[1].(string)]
	}).(ScriptOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ScriptInput)(nil)).Elem(), &Script{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScriptArrayInput)(nil)).Elem(), ScriptArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScriptMapInput)(nil)).Elem(), ScriptMap{})
	pulumi.RegisterOutputType(ScriptOutput{})
	pulumi.RegisterOutputType(ScriptArrayOutput{})
	pulumi.RegisterOutputType(ScriptMapOutput{})
}
